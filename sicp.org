* Introduction
Computer science is neither science nor about computers. It has more in common with magic.
The only reason why large programs are possible is because there are techniques for controlling the complexity of large systems.
** Primitives in LISP/Scheme
Every powerful language has three mechanisms to accomplish the construction of complex ideas from simple ones:
- primtive expressions, which represent the simplest entities the language is concerned with.
- means of combination, by which compound elements are built from simpler ones.
- means of abstraction, by which compound elements can be named and manipulated as units.
Expressions representing numbers maay be combined with an expression representing a primitive procedure (such as + or /).
Expressions formed by deliminiting a list of expressions within a set of parentheses are called *combinations*. The left more elements are called *operands*.
Note that simply expressing a number itself is a primitive operation.
#+begin_src scheme
(/ 140 120)
#+end_src
#+RESULTS:
: 7/6
#+begin_src scheme
(/ 143.2 120)
#+end_src
#+RESULTS:
: 1.1933333333333331
#+begin_src scheme
(* 143 120)
#+end_src
#+RESULTS:
: 17160
#+begin_src scheme
(+ 143 120)
#+end_src
#+RESULTS:
: 263
#+begin_src scheme
(- 143 120)
#+end_src
#+RESULTS:
: 23

** Nested combinations
An advantage of prefix notation is that it extends in a straightforward way to allow combinations to be *nested*. That is to have combinations whose elements are themselves combinations:
#+begin_src scheme
(+ (* 2 5) (- 10 6))
#+end_src
We at times will use *pretty-printing*, in which each long combination is written so that the opearnds are aligned vertically. The indentations display clearly the structure of the expression.
#+begin_src scheme
(+ (* 3 (+ (* 2 4)(+ 3 5))) (+ (- 10 7) 6))
#+end_src
#+begin_src scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
#+end_src
Even with complex expressions, the interpreter always operates in the same basic cycle: it heads an expression from the terminal, evaluates the expression, and print the results.
This mode of operation is often expressed by saying the interpreter runs in a _read-eval-print-loop_. Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression.

- THOUGHTS: This seems to imply to me that functional languages in a sense inherently recursive, all read-eval-print loops look like they simply end with the expression of the outer most function. This is so stack like that I doubt it is a coincidence. I guess I am assuming stack => recursion.

** Naming and Environment
Names are used to refer to computational objects. We say that names identify a variable whose value is the object.
__define__
#+begin_src scheme
(define size 2)
#+end_src
This causes the interpreter to associate the value 2 with the name size. Now we can refer to the value 2 by the name:
#+begin_src scheme
(define size 2)
(* 5 size)
#+end_src
Here is another example:
#+begin_src scheme
(define pi 3.14159)
(define radius 10)
(define area (* pi (* radius radius)))
area
#+end_src
Define is Scheme's simplest means of abstraction, as it allows us to use simple names to refer to the results of compound operations.
Clearly memory is being involved; that is it is keeping track of name-object pairs. We call this memory *the environment*. In this case we speak of the global environment in particular.
** Evaluating Combinations
*THIS CHAPTER IS ABOUT ISSUES IN PROCEDURAL THINKING!*
As a case in point, let us consider that in evaluating combinations, the interpreter is ITSELF following a procedure.
- TO EVALUATE A COMBINATION, DO THE FOLLOWING:
- 1. Evaluate the subexpressions of the combination.
- 2. Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (operands).

Ahah, I knew my thought in the nested combinations section was on to something! Observe that the first step dictates that the evaluation process for a combination first involves evaluaing it's subexpressions. The evaluation rule is therefor RECURSIVE in nature, that is, the read-eval-print loop must invoke ITSELF in evaluating a complex expression, it itself containing all the procedural notions needed to communicate with the CPU.
Notice how succintly the idea of recursion can be used to express what, would otherwise be viewed as a rather complicated process. For example, evaluating
#+begin_src scheme
(* (+ 2 (* 4 6))
    (+ 3 5 7))
#+end_src
Notice the similarity of SICP's diagram for the read-eval-print loop and that to a stack. (Turn it upside down). Notice the similarities between a tree and stack.
Observe that each node in the read-eval-print loop is itself a primitive expression, such as a number, operator or a name. We handle the primitive cases by stipulating:
- Values of numerals are the numbers they name.
- Values of built in operators are machine instruction sequences to add/divide/multiply/divide, and/or, etc.
- Values of names are the objects associate with name-object pairs in environment; they are subbranches.
[[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/ch1-Z-G-1.gif]]

** Compound Procedures
Example of compound procedures.
#+begin_src scheme
(define (square x) (* x x))
(square 2)
#+end_src
Notice that square can also be used as a building block for other procedures. For example, we could express x^2 + y^2
#+begin_src scheme
(define (square x) (* x x))
(+ (square 2) (square 3))
#+end_src
Or if we would like to name this procedure and abstract even further. Note that bottom definitions are clearly being hoisted above the declaration of f.
#+begin_src scheme
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(f 5)
#+end_src
